<!DOCTYPE html>

<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>Si√™u Tr√≠ Nh·ªõ H·∫£i S·∫£n - ƒê·ªëi Kh√°ng</title>
<link href="https://fonts.googleapis.com/css2?family=Bangers&amp;family=Roboto:wght@700&amp;display=swap" rel="stylesheet"/>
<style>
    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    html, body { height: 100%; }
    body{
      margin:0; padding:0;
      height: 100vh; width: 100vw;
      background:#263238;
      font-family:'Roboto', sans-serif;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      touch-action: manipulation; /* gi·∫£m delay click tr√™n mobile */
    }

    /* ===== Header ===== */
    .scoreboard{
      /* b·ªè height c·ªë ƒë·ªãnh ƒë·ªÉ tr√°nh tr√†n/ƒë√® ch·ªØ tr√™n nhi·ªÅu k√≠ch th∆∞·ªõc m√†n h√¨nh */
      width:100%;
      display:flex;
      flex-wrap:wrap;
      gap: 12px;
      align-items:stretch;
      justify-content:space-between;
      padding: 64px 16px 12px 16px; /* ch·ª´a ch·ªó ch·∫Øc ch·∫Øn cho n√∫t tr√™n c√πng */
      background: rgba(0,0,0,0.3);
      flex-shrink:0;
      position: relative;
      min-height: 120px;
    }

    .top-center{
      position: static;
      transform: none;
      text-align:center;
      color:white;
      font-family:'Bangers', cursive;
      line-height:1.05;
      pointer-events:none;
      opacity:0.95;
      display:flex;
      flex-direction:column;
      justify-content:center;
      flex: 0 1 240px;
      min-width: 180px;
      padding: 6px 8px;
    }
    .top-center .series{
      font-size: 3.2vmin;
      letter-spacing: 0.3vmin;
    }
    .top-center .round{
      font-size: 3.0vmin;
      opacity:0.9;
    }

    .team-score{
      flex: 1 1 320px;
      min-width: 260px;
      /* b·ªè height:100% ƒë·ªÉ tr√°nh b·ªã √©p trong header v√† tr√†n ch·ªØ */
      display:grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
      align-items:center;
      padding: 12px 16px;
      border-radius: 18px;
      font-family:'Bangers', cursive;
      color:white;
      transition: 0.2s;
      opacity:0.55;
      border: 4px solid transparent;
      position: relative;
      overflow:hidden;
      gap: 8px 14px;
    }
    .team-score h2{
      margin:0;
      font-size: clamp(16px, 2.2vmin, 26px);
      text-transform: uppercase;
      line-height: 1.08;
      grid-column: 1; max-width: 100%;
      grid-row: 1;
      align-self:center;
    }
    .score-num{
      font-size: clamp(34px, 6vmin, 72px);
      color:#ffeb3b;
      text-shadow: 2px 2px 0 #000;
      min-width: 7vmin;
      text-align:center;
      grid-column: 2;
      grid-row: 1;
      align-self:center;
      justify-self:end;
    }
    .vs-text{
      flex: 0 0 auto;
      min-width: 48px;
      font-size: clamp(18px, 3.2vmin, 44px);
      color:white;
      font-family:'Bangers', cursive;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0.9;
      margin: 0 4px;
    }
    .meta .badge{
      background: rgba(0,0,0,0.25);
      padding: 0.4vh 1.4vw;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
    }
    .meta .timer{
      background: rgba(0,0,0,0.25);
      padding: 0.4vh 1.4vw;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      min-width: 9vmin;
      text-align:center;
    }

    .team-1{ background:#d32f2f; }
    .team-2{ background:#1976d2; }

    .team-score.active{
      opacity:1;
      transform: scale(1.02);
      box-shadow: 0 0 15px rgba(255,255,255,0.5);
      border-color: #ffeb3b;
    }

    .header-btns{
      position:absolute;
      left: 16px;
      right: 16px;
      top: 10px;
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      z-index: 3;
      pointer-events:none; /* ch·ªâ n√∫t nh·∫≠n click */
    }
    .mini-btn{
      pointer-events:auto;
      font-family:'Bangers', cursive;
      font-size: clamp(14px, 2.2vmin, 22px);
      padding: 8px 14px;
      border:none;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      color:white;
      border: 1px solid rgba(255,255,255,0.25);
      cursor:pointer;
      backdrop-filter: blur(6px);
    }
    .mini-btn:active{ transform: scale(0.98); }

    /* ===== Board ===== */
    .game-board{
      height: 85vh;
      width:100%;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 10px;
    }
    .grid{
      display:grid;
      gap: 1.2vmin;
      /* k√≠ch th∆∞·ªõc s·∫Ω ƒë∆∞·ª£c set b·∫±ng JS ƒë·ªÉ auto-fit */
      width: 92vw;
      height: 78vh;
      max-width: 100%;
      max-height: 100%;
    }

    .card{
      background: transparent;
      perspective: 1000px;
      cursor:pointer;
      position:relative;
      width:100%; height:100%;
      touch-action: manipulation;
    }
    .card-inner{
      position:relative;
      width:100%; height:100%;
      text-align:center;
      transition: transform 0.45s;
      transform-style: preserve-3d;
      border-radius: 1vmin;
      box-shadow: 0 0.5vmin 1vmin rgba(0,0,0,0.32);
      will-change: transform;
    }
    .card.flipped .card-inner{ transform: rotateY(180deg); }
    .card.matched .card-inner{ opacity: 0; cursor: default; }

    .card-front, .card-back{
      position:absolute;
      width:100%; height:100%;
      backface-visibility:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 1vmin;
      border: 2px solid rgba(255,255,255,0.18);
    }
    .card-front{
      background: linear-gradient(135deg, #455a64, #37474f);
      color:#90a4ae;
      font-size: 4vmin;
    }
    .card-back{
      background:white;
      color:black;
      transform: rotateY(180deg);
      font-size: 6vmin;
    }

    /* ===== Modal ===== */
    .modal{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.9);
      display:none;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      z-index: 100;
      text-align:center;
      color:white;
      padding: 3vh 4vw;
    }
    .modal.show{ display:flex; }
    .modal h1{
      font-family:'Bangers', cursive;
      font-size: 7.5vmin;
      margin: 0 0 1vh 0;
      color: #ffeb3b;
      text-shadow: 0.6vmin 0.6vmin 0 #000;
    }
    .modal p{ font-size: 3vmin; margin: 0.5vh 0; opacity:0.92; }
    .btn{
      font-family:'Bangers', cursive;
      font-size: 3vmin;
      padding: 1.5vh 4vw;
      border:none;
      border-radius: 999px;
      cursor:pointer;
      margin-top: 1.6vh;
    }
    .btn-primary{ background:#43a047; color:white; }
    .btn-secondary{ background: rgba(255,255,255,0.12); color:white; border: 1px solid rgba(255,255,255,0.25); }

    /* ===== Settings ===== */
    .panel{
      width: min(92vw, 520px);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 18px;
      padding: 18px 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
      margin: 10px 0;
      font-size: 3vmin;
    }
    .row label{ opacity:0.95; }
    select, input[type="number"]{
      font-size: 3vmin;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.25);
      color: white;
      outline: none;
      width: 46%;
    }
    .hint{
      font-size: 2.4vmin;
      opacity: 0.85;
      margin-top: 8px;
      line-height: 1.25;
    }

    /* ===== Confetti canvas ===== */
    #fxCanvas{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index: 999;
    }
  
    @media (max-width: 520px){
      .scoreboard{ padding: 58px 12px 10px 12px; gap: 10px; }
      .team-score{ flex: 1 1 100%; min-width: 0; }
      .team-1{ order: 1; }
      .team-2{ order: 2; }
      .top-center{ flex: 1 1 100%; min-width: 0; order: 3; }
      .vs-text{ display:none; }
      .header-btns{ left: 12px; right: 12px; top: 8px; }
      .mini-btn{ padding: 8px 12px; }
    }
  

    /* ===== Responsive layout v3 (iPad/iPhone landscape + Mac) ===== */
    :root{
      --safeTop: env(safe-area-inset-top);
      --safeRight: env(safe-area-inset-right);
      --safeBottom: env(safe-area-inset-bottom);
      --safeLeft: env(safe-area-inset-left);
    }
    html, body { height: 100%; }
    body{
      height: 100dvh; /* iOS dynamic viewport */
      width: 100vw;
      padding: 0;
    }

    /* Header as CSS grid to avoid overlap */
    .scoreboard{
      display:grid;
      grid-template-columns: 1fr minmax(140px, 240px) 1fr;
      grid-template-rows: auto auto;
      grid-template-areas:
        "controls controls controls"
        "team1 mid team2";
      gap: 10px;
      padding: calc(var(--safeTop) + 10px) calc(var(--safeRight) + 12px) 10px calc(var(--safeLeft) + 12px);
      min-height: unset;
      align-items: stretch;
    }
    .header-btns{
      position: static;
      grid-area: controls;
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      pointer-events:auto;
    }
    #scoreBoard1{ grid-area: team1; }
    #scoreBoard2{ grid-area: team2; }
    .mid{
      grid-area: mid;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap: 6px;
      pointer-events:none;
    }
    .top-center{
      flex: 0 0 auto;
      min-width: unset;
      padding: 0;
    }
    .vs-text{
      opacity: 0.9;
      margin: 0;
      line-height: 1;
    }

    /* Board should fill remaining space, no fixed vh */
    .game-board{
      flex: 1 1 auto;
      height: auto;
      min-height: 0;
      padding: 10px calc(var(--safeRight) + 10px) calc(var(--safeBottom) + 10px) calc(var(--safeLeft) + 10px);
      align-items: stretch;
    }
    .grid{
      width: 100%;
      height: 100%;
      max-width: 96vw;
      max-height: 100%;
    }

    /* iPhone portrait: stack header blocks */
    @media (max-width: 520px){
      .scoreboard{
        grid-template-columns: 1fr;
        grid-template-areas:
          "controls"
          "team1"
          "mid"
          "team2";
      }
      .header-btns{ justify-content:space-between; }
      .mid{ flex-direction:row; gap: 12px; }
      .vs-text{ display:none; }
    }

    /* iPhone landscape: reduce header footprint */
    @media (max-height: 430px) and (orientation: landscape){
      .scoreboard{
        grid-template-columns: 1fr minmax(120px, 190px) 1fr;
        gap: 8px;
        padding: calc(var(--safeTop) + 6px) calc(var(--safeRight) + 10px) 6px calc(var(--safeLeft) + 10px);
      }
      .mini-btn{
        padding: 6px 10px;
        font-size: 14px;
      }
      .team-score{
        padding: 8px 10px;
        border-radius: 14px;
        border-width: 3px;
      }
      .team-score h2{
        font-size: 14px;
      }
      .score-num{
        font-size: clamp(24px, 7vh, 46px);
        min-width: 44px;
      }
      .meta .badge{ display:none; } /* ch·ª´a ch·ªó */
      .meta .timer{
        padding: 2px 8px;
        min-width: 64px;
        font-size: 12px;
      }
      .top-center .series{ font-size: 16px; letter-spacing: 1px; }
      .top-center .round{ font-size: 14px; }
      .vs-text{ font-size: 16px; }
    }

    /* iPad landscape: keep one row but tidy spacing */
    @media (min-width: 768px) and (orientation: landscape){
      .scoreboard{
        grid-template-columns: 1fr minmax(180px, 280px) 1fr;
        gap: 12px;
      }
      .mini-btn{ font-size: 18px; padding: 8px 14px; }
    }
</style>
</head>
<body>
<canvas id="fxCanvas"></canvas>
<div class="scoreboard">
<div class="header-btns">
<button class="mini-btn" id="btnSettings">‚öôÔ∏è Thi·∫øt l·∫≠p</button>
<button class="mini-btn" id="btnRestart">üîÅ Reset v√°n</button>
</div>
<div class="team-score team-1 active" id="scoreBoard1">
<h2>Team ƒê·ªè<br/>(T√¥m)</h2>
<div class="score-num" id="score1">0</div>
<div class="meta">
<div class="badge">T·ª∑ s·ªë: <span id="matchScore1">0</span></div>
<div class="timer">‚è≥ <span id="timer1">10</span>s</div>
</div>
</div><div class="mid"><div class="top-center">
<div class="series">V√ÅN: <span id="roundNow">1</span>/<span id="roundTotal">2</span></div>
<div class="round">√î: <span id="cellsNow">50</span> ‚Ä¢ L∆∞·ª£t: <span id="turnNow">ƒê·ªé</span></div>
</div><div class="vs-text">VS</div></div>


<div class="team-score team-2" id="scoreBoard2">
<div class="score-num" id="score2">0</div>
<h2 style="text-align:right">Team Xanh<br/>(Cua)</h2>
<div class="meta">
<div class="badge">T·ª∑ s·ªë: <span id="matchScore2">0</span></div>
<div class="timer">‚è≥ <span id="timer2">10</span>s</div>
</div>
</div>
</div>
<div class="game-board">
<div class="grid" id="grid"></div>
</div>
<!-- Settings Modal -->
<div class="modal show" id="settingsModal">
<div class="panel">
<h1 style="font-size:7vmin;margin:0 0 1vh 0;">THI·∫æT L·∫¨P</h1>
<div class="row">
<label for="gamesSelect">Ch∆°i t·ªïng s·ªë v√°n</label>
<select id="gamesSelect">
<option value="2">2 v√°n</option>
<option value="4">4 v√°n</option>
</select>
</div>
<div class="row">
<label for="cellsInput">S·ªë √¥ (ch·∫µn)</label>
<input id="cellsInput" max="120" min="10" step="2" type="number" value="50"/>
</div>
<div class="row">
<label for="turnTimeSelect">Th·ªùi gian/l∆∞·ª£t</label>
<select id="turnTimeSelect">
<option value="10">10s</option>
<option value="8">8s</option>
<option value="12">12s</option>
</select>
</div>
<div class="hint">
        ‚Ä¢ H·∫øt th·ªùi gian m√† <b>kh√¥ng b·∫•m</b> s·∫Ω t·ª± chuy·ªÉn l∆∞·ª£t.<br>
        ‚Ä¢ N·∫øu sau N v√°n m√† h√≤a, h·ªá th·ªëng t·ª± th√™m <b>1 v√°n chung k·∫øt</b>.<br>
        ‚Ä¢ T·ª± co d√£n √¥ ƒë·ªÉ v·ª´a m√†n h√¨nh theo s·ªë √¥ b·∫°n ch·ªçn.
      </br></br></div>
<button class="btn btn-primary" id="btnApply">B·∫ÆT ƒê·∫¶U CH∆†I</button>
<button class="btn btn-secondary" id="btnCloseSettings" style="margin-left:10px;">ƒê√ìNG</button>
</div>
</div>
<!-- End Modal -->
<div class="modal" id="endModal">
<h1 id="winnerText">WINNER</h1>
<p id="winnerSub">K·∫øt th√∫c!</p>
<button class="btn btn-primary" id="btnNewMatch">CH∆†I TR·∫¨N M·ªöI</button>
</div>
<script>
(() => {
  // ====== Emoji pool (ƒë·ªß l·ªõn cho nhi·ªÅu √¥) ======
    const EMOJIS = [
    'ü¶û', 'ü¶Ä', 'ü¶ë', 'üêô', 'ü¶ê', 'üê†', 'üêü', 'üê°', 'ü¶à', 'üê¨', 'üê≥', 'üêã',
    'ü¶≠', 'ü¶©', 'ü¶¢', 'üêö', 'ü™∏', 'ü¶™', 'ü™º', 'üç§', 'üç£', 'üç•', 'üç±', 'üçô',
    'üçö', 'üçú', 'üç≤', 'ü•ü', 'üç°', 'üçß', 'üç®', 'ü•§', 'üßã', 'üç∫', 'üßÉ', 'üçï',
    'üçî', 'üå≠', 'üçü', 'üåÆ', 'üåØ', 'ü•™', 'ü•ó', 'üíé', 'üí∞', 'üéÅ', 'üéà', 'üéâ',
    '‚≠ê', 'üåü', 'üî•', '‚ö°', 'üéØ', 'üé≤', 'üßß', 'üê∏', 'üêØ', 'ü¶ä', 'üêº', 'ü¶Å',
    'üêµ', 'üêß', 'ü¶Ñ', 'üêù', 'ü¶ã', 'üêû', 'ü¶ñ', 'ü¶ï', 'ü¶î', 'üê¢', 'ü¶é', 'üêä'
  ];

  // ====== DOM ======
  const grid = document.getElementById('grid');

  const score1El = document.getElementById('score1');
  const score2El = document.getElementById('score2');
  const board1 = document.getElementById('scoreBoard1');
  const board2 = document.getElementById('scoreBoard2');

  const matchScore1El = document.getElementById('matchScore1');
  const matchScore2El = document.getElementById('matchScore2');

  const timer1El = document.getElementById('timer1');
  const timer2El = document.getElementById('timer2');

  const roundNowEl = document.getElementById('roundNow');
  const roundTotalEl = document.getElementById('roundTotal');
  const cellsNowEl = document.getElementById('cellsNow');
  const turnNowEl = document.getElementById('turnNow');

  const settingsModal = document.getElementById('settingsModal');
  const gamesSelect = document.getElementById('gamesSelect');
  const cellsInput = document.getElementById('cellsInput');
  const turnTimeSelect = document.getElementById('turnTimeSelect');
  const btnApply = document.getElementById('btnApply');
  const btnCloseSettings = document.getElementById('btnCloseSettings');

  const btnSettings = document.getElementById('btnSettings');
  const btnRestart = document.getElementById('btnRestart');

  const endModal = document.getElementById('endModal');
  const winnerText = document.getElementById('winnerText');
  const winnerSub = document.getElementById('winnerSub');
  const btnNewMatch = document.getElementById('btnNewMatch');

  // ====== Audio (WebAudio nh·∫π, kh√¥ng lag khi spam) ======
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  }
  function beep(type){
    // type: 'flip' 'match' 'fail' 'win'
    if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    const cfg = {
      flip:  { f: 520, dur: 0.04, gain: 0.14 },
      match: { f: 820, dur: 0.08, gain: 0.13 },
      fail:  { f: 180, dur: 0.10, gain: 0.12 },
      win:   { f: 980, dur: 0.20, gain: 0.14 },
    }[type] || { f: 440, dur: 0.05, gain: 0.10 };

    o.type = (type === 'fail') ? 'sawtooth' : 'triangle';
    o.frequency.setValueAtTime(cfg.f, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(cfg.gain, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + cfg.dur);

    o.connect(g); g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + cfg.dur + 0.02);
  }
  // "Unlock" √¢m thanh ngay khi ng∆∞·ªùi ch∆°i ch·∫°m l·∫ßn ƒë·∫ßu (iOS/Safari hay ch·∫∑n autoplay)
  window.addEventListener('pointerdown', () => {
    ensureAudio();
  }, { passive: true, once: true });


  // ====== Confetti ======
  const fx = document.getElementById('fxCanvas');
  const fxc = fx.getContext('2d');
  let fxW = 0, fxH = 0;
  function resizeFx(){
    fxW = fx.width = window.innerWidth * devicePixelRatio;
    fxH = fx.height = window.innerHeight * devicePixelRatio;
  }
  window.addEventListener('resize', () => { resizeFx(); fitGridToScreen(); }, {passive:true});
  resizeFx();

  let confetti = [];
  function burstConfetti(intensity=160){
    const centerX = fxW * 0.5;
    const centerY = fxH * 0.28;
    for(let i=0;i<intensity;i++){
      const a = Math.random() * Math.PI * 2;
      const sp = (Math.random()*6 + 6) * devicePixelRatio;
      confetti.push({
        x:centerX, y:centerY,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp - 6*devicePixelRatio,
        g: (0.28 + Math.random()*0.18) * devicePixelRatio,
        r: (2 + Math.random()*4) * devicePixelRatio,
        rot: Math.random()*Math.PI*2,
        vr: (Math.random()-0.5)*0.35,
        life: 70 + Math.random()*35
      });
    }
    if(!fxAnimating) requestAnimationFrame(fxLoop);
  }
  let fxAnimating = false;
  function fxLoop(){
    fxAnimating = true;
    fxc.clearRect(0,0,fxW,fxH);
    confetti = confetti.filter(p => p.life > 0);
    for(const p of confetti){
      p.life -= 1;
      p.vy += p.g;
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;

      // m√†u random theo g√≥c quay (kh√¥ng set "m√†u c·ªë ƒë·ªãnh", nh∆∞ng v·∫´n r·ª±c)
      const hue = (p.rot*180/Math.PI) % 360;
      fxc.fillStyle = `hsl(${hue}, 95%, 60%)`;
      fxc.save();
      fxc.translate(p.x, p.y);
      fxc.rotate(p.rot);
      fxc.fillRect(-p.r, -p.r*0.4, p.r*2, p.r*0.8);
      fxc.restore();
    }
    if(confetti.length){
      requestAnimationFrame(fxLoop);
    }else{
      fxAnimating = false;
      fxc.clearRect(0,0,fxW,fxH);
    }
  }

  // ====== Game state ======
  let settings = {
    totalGames: 2,
    cells: 50,
    turnTime: 10
  };

  let roundIndex = 1;
  let plannedRounds = 2;  // c√≥ th·ªÉ +1 n·∫øu h√≤a
  let matchWins = {1:0, 2:0};

  // round-specific
  let turn = 1; // 1 ƒë·ªè, 2 xanh
  let scores = {1:0, 2:0};
  let flippedCards = [];
  let lockBoard = false;
  let matchedPairs = 0;
  let totalPairs = 0;

  // timer
  let remaining = 10;
  let timerTick = null;
  let lastActionTs = performance.now();

  // performance: gi·ªõi h·∫°n √¢m thanh 1 l·∫ßn / frame
  let soundQueued = null;
  function queueSound(type){
    soundQueued = type;
  }
  function soundFrame(){
    if(soundQueued){
      beep(soundQueued);
      soundQueued = null;
    }
    requestAnimationFrame(soundFrame);
  }
  requestAnimationFrame(soundFrame);

  function setTurn(newTurn){
    turn = newTurn;
    updateTurnUI();
    resetTurnTimer();
  }

  function resetTurnTimer(){
    remaining = settings.turnTime;
    lastActionTs = performance.now();
    renderTimer();
  }

  function renderTimer(){
    if(turn === 1){
      timer1El.textContent = String(Math.max(0, remaining));
      timer2El.textContent = String(settings.turnTime);
    }else{
      timer2El.textContent = String(Math.max(0, remaining));
      timer1El.textContent = String(settings.turnTime);
    }
  }

  function startTimer(){
    stopTimer();
    timerTick = setInterval(() => {
      const now = performance.now();
      const idleSec = Math.floor((now - lastActionTs)/1000);
      const newRemaining = Math.max(0, settings.turnTime - idleSec);
      if(newRemaining !== remaining){
        remaining = newRemaining;
        renderTimer();
      }
      if(remaining <= 0){
        // h·∫øt th·ªùi gian m√† kh√¥ng b·∫•m -> ƒë·ªïi l∆∞·ª£t
        if(!lockBoard){
          setTurn(turn === 1 ? 2 : 1);
        }else{
          // ƒëang lock (ƒë·ª£i l·∫≠t l·∫°i), v·∫´n ƒë·ªïi sau khi unlock
          // ƒë·ªÉ tr√°nh "ƒë·ªïi gi·ªØa animation" -> ƒë√°nh d·∫•u v√† ƒë·ªïi ngay khi unlock
          pendingAutoSwitch = true;
        }
      }
    }, 200);
  }
  function stopTimer(){
    if(timerTick){ clearInterval(timerTick); timerTick = null; }
  }
  let pendingAutoSwitch = false;

  function updateScoreUI(){
    score1El.textContent = scores[1];
    score2El.textContent = scores[2];
  }
  function updateMatchUI(){
    matchScore1El.textContent = matchWins[1];
    matchScore2El.textContent = matchWins[2];
  }
  function updateRoundUI(){
    roundNowEl.textContent = roundIndex;
    roundTotalEl.textContent = plannedRounds;
    cellsNowEl.textContent = settings.cells;
  }

  function updateTurnUI(){
    if(turn === 1){
      board1.classList.add('active'); board2.classList.remove('active');
      turnNowEl.textContent = 'ƒê·ªé';
    }else{
      board2.classList.add('active'); board1.classList.remove('active');
      turnNowEl.textContent = 'XANH';
    }
    renderTimer();
  }

  function calcGridDims(n){
    // ch·ªçn s·ªë c·ªôt g·∫ßn sqrt(n) nh∆∞ng ∆∞u ti√™n nhi·ªÅu c·ªôt h∆°n ƒë·ªÉ √¥ kh√¥ng qu√° cao
    let cols = Math.ceil(Math.sqrt(n));
    // n l·ªõn, tƒÉng cols m·ªôt ch√∫t ƒë·ªÉ b·ªõt cao (m∆∞·ª£t cho 50 √¥)
    cols = Math.min(Math.max(cols, 5), 14);
    let rows = Math.ceil(n / cols);

    // n·∫øu c√≤n d∆∞ nhi·ªÅu ·ªü h√†ng cu·ªëi, th·ª≠ tƒÉng cols ƒë·ªÉ gi·∫£m rows
    while(cols < 16 && (rows - 1) * cols >= n){
      rows -= 1;
    }
    // ƒë·∫£m b·∫£o cols*rows >= n
    while(cols*rows < n) rows += 1;

    return {cols, rows};
  }

  function fitGridToScreen(){
    const n = settings.cells;
    const {cols, rows} = calcGridDims(n);

    grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

    // set width/height theo v√πng c√≥ s·∫µn ƒë·ªÉ auto-fit kh√¥ng tr√†n
    const board = document.querySelector('.game-board');
    const availW = board.clientWidth - 20;
    const availH = board.clientHeight - 20;

    const cell = Math.floor(Math.min(availW/cols, availH/rows));
    const w = cell * cols;
    const h = cell * rows;

    grid.style.width = w + 'px';
    grid.style.height = h + 'px';

    // scale font theo cell (·ªïn cho nhi·ªÅu √¥)
    const frontSize = Math.max(14, Math.floor(cell*0.45));
    const backSize  = Math.max(16, Math.floor(cell*0.62));
    document.documentElement.style.setProperty('--frontSize', frontSize+'px');
    document.documentElement.style.setProperty('--backSize', backSize+'px');

    // apply to cards via inline style (nh·∫π, tr√°nh css calc ph·ª©c t·∫°p)
    grid.querySelectorAll('.card-front').forEach(el => el.style.fontSize = frontSize + 'px');
    grid.querySelectorAll('.card-back').forEach(el => el.style.fontSize = backSize + 'px');
  }

  function buildDeck(){
    const n = settings.cells;
    const pairs = Math.floor(n/2);
    totalPairs = pairs;

    // ch·ªçn pairs emoji duy nh·∫•t
    const pool = [...EMOJIS];
    // shuffle pool
    for(let i=pool.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    const chosen = pool.slice(0, pairs);
    const deck = [...chosen, ...chosen];

    // shuffle deck (Fisher-Yates)
    for(let i=deck.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  }

  function initRound(){
    // reset round state
    scores = {1:0, 2:0};
    flippedCards = [];
    lockBoard = false;
    matchedPairs = 0;
    pendingAutoSwitch = false;

    updateScoreUI();
    updateRoundUI();
    updateTurnUI();

    const deck = buildDeck();
    grid.innerHTML = '';

    for(let i=0;i<deck.length;i++){
      const icon = deck[i];
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.icon = icon;
      card.innerHTML = `
        <div class="card-inner">
          <div class="card-front">?</div>
          <div class="card-back">${icon}</div>
        </div>
      `;

      // pointerdown h·ªó tr·ª£ ƒëa ch·∫°m t·ªët h∆°n click
      card.addEventListener('pointerdown', (e) => {
        // iOS/Safari: c·∫ßn "unlock" AudioContext trong user gesture
        ensureAudio();
        const didFlip = flipCard(card);
        if(didFlip){
          // ph√°t ngay trong gesture ƒë·ªÉ ch·∫Øc ch·∫Øn kh√¥ng b·ªã ch·∫∑n
          beep('flip');
        }
      }, {passive:true});

      grid.appendChild(card);
    }

    fitGridToScreen();
    resetTurnTimer();
    startTimer();
  }

  function flipCard(card){
    if(lockBoard) return false;
    if(card.classList.contains('matched') || card.classList.contains('flipped')) return false;
    if(flippedCards.length === 1 && flippedCards[0] === card) return false;

    // c√≥ h√†nh ƒë·ªông h·ª£p l·ªá -> reset "idle timer"
    lastActionTs = performance.now();
    remaining = settings.turnTime;
    renderTimer();

    card.classList.add('flipped');
    flippedCards.push(card);

    if(flippedCards.length === 2){
      checkForMatch();
    }
    return true;
  }

  function checkForMatch(){
    const [c1, c2] = flippedCards;
    const isMatch = c1.dataset.icon === c2.dataset.icon;
    if(isMatch) disableCards(); else unflipCards();
  }

  function disableCards(){
    lockBoard = true;
    queueSound('match');

    setTimeout(() => {
      flippedCards.forEach(c => c.classList.add('matched'));
      scores[turn] += 1; // 1 ƒëi·ªÉm = 1 c·∫∑p
      matchedPairs += 1;
      updateScoreUI();

      flippedCards = [];
      lockBoard = false;

      if(matchedPairs >= totalPairs){
        endRound();
        return;
      }

      // ƒë√∫ng th√¨ gi·ªØ l∆∞·ª£t, nh∆∞ng reset timer v√¨ v·ª´a "ho√†n th√†nh"
      resetTurnTimer();

      if(pendingAutoSwitch){
        pendingAutoSwitch = false;
        setTurn(turn === 1 ? 2 : 1);
      }
    }, 420);
  }

  function unflipCards(){
    lockBoard = true;
    queueSound('fail');

    setTimeout(() => {
      flippedCards.forEach(c => c.classList.remove('flipped'));
      flippedCards = [];
      lockBoard = false;

      // sai -> ƒë·ªïi l∆∞·ª£t
      setTurn(turn === 1 ? 2 : 1);

      if(pendingAutoSwitch){
        pendingAutoSwitch = false;
        setTurn(turn === 1 ? 2 : 1);
      }
    }, 520);
  }

  function endRound(){
    stopTimer();
    lockBoard = true;

    const s1 = scores[1], s2 = scores[2];
    let roundWinner = 0;
    let msg = '';
    if(s1 > s2){ roundWinner = 1; msg = 'üèÜ ƒê·ªé TH·∫ÆNG V√ÅN!'; }
    else if(s2 > s1){ roundWinner = 2; msg = 'üèÜ XANH TH·∫ÆNG V√ÅN!'; }
    else { msg = 'ü§ù V√ÅN H√íA!'; }

    if(roundWinner){
      matchWins[roundWinner] += 1;
      updateMatchUI();
      queueSound('win');
      burstConfetti(220);
    }else{
      burstConfetti(120);
    }

    // chuy·ªÉn sang v√°n ti·∫øp theo ho·∫∑c k·∫øt th√∫c tr·∫≠n
    setTimeout(() => {
      if(shouldContinueMatch()){
        roundIndex += 1;
        initRound();
      }else{
        endMatch();
      }
    }, 900);
  }

  function shouldContinueMatch(){
    // Sau khi ch∆°i ƒë·ªß plannedRounds, n·∫øu h√≤a matchWins -> th√™m 1 v√°n chung k·∫øt (ch·ªâ th√™m 1 l·∫ßn)
    if(roundIndex < plannedRounds) return true;

    if(roundIndex >= plannedRounds){
      if(matchWins[1] === matchWins[2]){
        // h√≤a -> th√™m 1 v√°n chung k·∫øt (n·∫øu ch∆∞a th√™m)
        plannedRounds = settings.totalGames + 1;
        roundTotalEl.textContent = plannedRounds;
        return roundIndex < plannedRounds; // s·∫Ω true v√¨ roundIndex == totalGames
      }
      return false;
    }
    return false;
  }

  function endMatch(){
    stopTimer();
    lockBoard = true;

    const m1 = matchWins[1], m2 = matchWins[2];
    let msg = '';
    if(m1 > m2) msg = 'üéâ CHUNG CU·ªòC: TEAM ƒê·ªé V√î ƒê·ªäCH!';
    else if(m2 > m1) msg = 'üéâ CHUNG CU·ªòC: TEAM XANH V√î ƒê·ªäCH!';
    else msg = 'ü§ù CHUNG CU·ªòC H√íA!';

    winnerText.textContent = msg;
    winnerSub.textContent = `T·ª∑ s·ªë chung cu·ªôc: ${m1} - ${m2} ‚Ä¢ S·ªë √¥: ${settings.cells}`;
    endModal.classList.add('show');

    burstConfetti(420);
    queueSound('win');
  }

  function resetMatch(keepSettings=true){
    endModal.classList.remove('show');

    roundIndex = 1;
    plannedRounds = settings.totalGames;
    matchWins = {1:0, 2:0};
    updateMatchUI();
    updateRoundUI();

    // reset turn
    setTurn(1);
    initRound();

    if(!keepSettings){
      // n·∫øu c·∫ßn m·ªü settings l·∫°i
      settingsModal.classList.add('show');
    }
  }

  // ===== UI events =====
  btnApply.addEventListener('click', () => {
    const tg = parseInt(gamesSelect.value, 10);
    let cells = parseInt(cellsInput.value, 10);
    const tt = parseInt(turnTimeSelect.value, 10);

    if(!Number.isFinite(cells)) cells = 50;
    // ƒë·∫£m b·∫£o ch·∫µn
    if(cells % 2 === 1) cells += 1;
    // clamp
    cells = Math.max(10, Math.min(120, cells));

    settings.totalGames = (tg === 4 ? 4 : 2);
    settings.cells = cells;
    settings.turnTime = (tt === 8 ? 8 : (tt === 12 ? 12 : 10));

    plannedRounds = settings.totalGames;
    roundTotalEl.textContent = plannedRounds;
    cellsNowEl.textContent = settings.cells;

    settingsModal.classList.remove('show');
    resetMatch(true);
  });

  btnCloseSettings.addEventListener('click', () => {
    settingsModal.classList.remove('show');
  });

  btnSettings.addEventListener('click', () => {
    settingsModal.classList.add('show');
  });

  btnRestart.addEventListener('click', () => {
    // reset ri√™ng v√°n hi·ªán t·∫°i
    initRound();
  });

  btnNewMatch.addEventListener('click', () => {
    endModal.classList.remove('show');
    settingsModal.classList.add('show');
  });

  // ===== Boot =====
  updateMatchUI();
  updateRoundUI();
  updateTurnUI();

  // ch∆∞a init round ngay; ch·ªù b·∫•m "B·∫Øt ƒë·∫ßu ch∆°i" trong settings
})();
</script>
</body>
</html>
